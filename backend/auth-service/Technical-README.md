# Auth Microservice Technical Explanation

## Understanding JWT

The JWT (JSON Web Token) isn't actually hashed—it's encoded and signed.

### Structure of a JWT

A JWT consists of three parts separated by dots:

1. **Header**: Contains metadata about the token, including the signing algorithm and token type.
2. **Payload**: Contains the user data and claims (information about the user).
3. **Signature**: Used to verify the authenticity of the token.

### Creating a JWT

Looking at where we create the token in the `generate_tokens()` function:

```python
access_token_payload = {
    'sub': str(user.id),
    'username': user.username,
    'roles': [role.name for role in user.roles],
    'permissions': [perm for role in user.roles for perm in role.get_permissions()],
    'exp': datetime.datetime.utcnow() + app_config.JWT_ACCESS_TOKEN_EXPIRES,
    'iat': datetime.datetime.utcnow(),
    'jti': str(uuid.uuid4())
}

access_token = jwt.encode(
    access_token_payload,
    app_config.JWT_SECRET_KEY,
    algorithm='HS256'
)
```

- The **payload** contains all the user information (ID, username, roles, permissions) in plain JSON format. This data is then base64url encoded (not encrypted or hashed).
- The **signature** is created by taking the encoded header and payload, combining them with a secret key, and applying the algorithm specified in the header (HS256 in this case).

### Validating a JWT

When `validate_access_token()` is called:

```python
payload = jwt.decode(
    token,
    app_config.JWT_SECRET_KEY,
    algorithms=['HS256']
)
```

- It uses the secret key to verify the signature, ensuring that nobody tampered with the token. Then it decodes the payload to access the user information.

### Important Security Note

Since the payload is only base64 encoded (not encrypted), anyone can decode it to read the information inside. That's why we should never put sensitive data like passwords in a JWT. The security comes from the signature, which prevents modification, not from hiding the contents.

When a server receives a JWT, it can verify the signature by performing the same encoding and signing process using the same secret key. If the signature generated by the server matches the signature in the JWT, it confirms that the token has not been tampered with and is valid. The security of the JWT signature relies on the secrecy of the key used to create it. If an attacker does not have access to the secret key, they cannot generate a valid signature for a JWT that would be accepted by the server. The server can detect any unauthorized changes to the token because the signature will not be valid if the payload or header is altered.

Each JWT is unique because it includes a payload that typically contains user-specific information (like user ID, roles, etc.) and a unique identifier (like jti for JWT ID). Even if two tokens are signed with the same secret key, they will have different payloads and thus different signatures.

### Summary of JWT Functionality

- **Stateless**: JWTs are stateless and self-contained, meaning they carry all the necessary information about the user within the token itself.
- **Efficiency**: Because the server does not need to query the database to verify user information, this speeds up authentication.
- **Integrity**: The signature ensures that the token has not been altered, providing a layer of security against tampering.


## JWT Authentication Workflow

The authentication flow works through several steps:

1. When a user logs in, a JWT (JSON Web Token) is generated containing their identity and permissions.
2. This token is sent back to the client, who stores it via the browser cache most likely.
3. For protected endpoints, the client includes this token in the Authorization header.

### @authenticate Decorator Middleware

The `@authenticate` decorator middleware:

- Extracts the token from the header.
- Validates it with `AuthService.validate_access_token()`.
- If valid, stores the decoded user information in Flask's `g` object.
    - Note that flask's g object is a global object used to store data during the request lifecycle - it's unique to each request.
- Then allows the request to continue to the route handler.

The route handler can then access this user data from `g` to personalize the response.

### Key Points

- JWTs are stateless and self-contained. They include all the necessary user information (ID, username, roles, permissions) encoded within the token itself. This token is cryptographically signed using the secret key in `.env`, so it can't be tampered with without invalidation.
- When `AuthService.validate_access_token()` verifies the token, it:
  - Checks the signature using the application's secret key.
  - Ensures the token hasn't expired.
  - Decodes the payload to get the user information (all the information is encoded in this JWT token in the payload section).

The beauty of this approach is that the server doesn't need to make a database call to verify who the user is — all the necessary information is in the token itself, which speeds up authentication.

**Note**: In the middleware, we're not using a database session, which is good for performance. However, keep in mind that if user permissions change, the token will still contain the old permissions until it expires or the user logs in again.

## SQLAlchemy Session Management

### Understanding SQLAlchemy Sessions
Database sessions in SQLAlchemy serve as a working context for operations involving the database, including:
- Querying data
- Adding new objects
- Modifying existing objects
- Deleting objects

### Scoped Sessions and Thread-Local Storage
In our application, we use SQLAlchemy's `scoped_session` configured in `db.py`:

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session
from ..config import app_config
from ..models import Base

# Create engine and session factory
engine = create_engine(app_config.SQLALCHEMY_DATABASE_URI)
session_factory = sessionmaker(bind=engine)
Session = scoped_session(session_factory)
```

#### What is a Scoped Session?
- A scoped session is a thread-local registry of sessions.
- Each thread gets its own session object.
- Access the current thread's session by calling methods on the `Session` registry.
- `Session.remove()` closes and removes the session for the current thread only.

### Session Lifecycle Management
1. **Creating a Session**:
   ```python
   def get_db_session():
       """Get a database session."""
       return Session()
   ```

2. **Committing Changes**:
   ```python
   db_session.commit()  # For a specific session instance
   # OR
   Session.commit()  # For the current thread's session
   ```
    It's safe to say that in most cases these two refer to and do the same thing.

3. **Closing a Session**:
   ```python
   # For a specific session instance
   db_session.close()

   # For the thread-local session
   def close_db_session(exception=None):
       """Close the database session."""
       Session.remove()
   ```
   Again, it's safe to say that in most cases these two refer to and do the same thing.

### Potential Issues with Improper Session Management
- **Connection leaks**: Exhausts the connection pool if sessions are not closed.
- **Resource consumption**: Open sessions consume memory and database resources.
- **Lock contention**: Unclosed sessions may hold locks, causing delays.
- **Performance degradation**: Accumulating connections can slow down the application and database.

### Summary
Using `scoped_session` provides a convenient way to manage database sessions by thread, but proper session cleanup is essential. The `finally` block ensures resources are cleaned up, making it crucial for robust session management.